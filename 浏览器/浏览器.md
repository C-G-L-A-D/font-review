# 1.  浏览器缓存

浏览器中的缓存分为两种情况：

* 强缓存，不需要发送HTTP请求
* 协商缓存，需要发送HTTP请求



## 1.2 缓存机制

 1. 首先浏览器会通过相应的字段来检测强缓存是否可用，在 `http1` 中 使用的是 **Expire** ，在 `http1.1` 之后使用的是 **catch-control**。这两个字段都是通过服务器的响应头进行返回。当两个字段同时存在时，有限考虑 **catch-control**。

    * **Expire**：`过期时间`， 表示客服端可以在这个过期时间之前直接从缓存中获取数据，无需请求。但是，由于服务器和客户端的时间可能不一样，导致过期时间并不准确。所以在 `http1.1` 被抛弃

    * **cache-control**：存储的是过期时长。例如 `cache-control:max-age=60` 即响应返回后60s失效。除了 `max-age` 属性外，还有：

      * `public`：表示客户端和代理服务器也可以缓存；

      * `private`：表示只有客服端可以缓存；

      * `no-cache`：跳过强缓存，直接进行协商缓存

      * `no-store`：表示不可以进行缓存

      * `s-maxage`：表示代理服务器得缓存时长。

        

 2. 如果强缓存失效了，就发送HTTP请求进行协商缓存。协商缓存通过在HTTP请求头中携带相应的 `缓存Tag` ，让服务器进行判断是否使用缓存还是更新资源。 `缓存Tag` 也分两种，在两种标识都存在的时候优先考虑**ETag** ，但是两种标识各有千秋。

    * **ETag**：由服务器根据资源的内容生成唯一的哈希值。由客户端发送请求头的 `If-None-Match` 携带，与服务器上资源的 **ETag** 进行判断，如果相同则返回304，让客户端使用缓存；反之，不相同则返回新的资源。
    * **Last-Modified**：存储的是资源最后的修改时间。由客户端发送请求头的`If-Modified-Since` 携带，与服务器上资源的最后修改时间进行比较。如果服务器最后修改时间较新，则返回新的资源；反之，返回304，让客户端使用缓存资源。

> 在 精确度 上，ETag 优于 Last-Modified，因为 ETag 是根据资源内容在判断，而Last-Modified的感知单位时间是秒，也就是说如果服务器上的资源在1s内多次修改，Last-Modified 是感知不到资源的修改。并且如果文件编辑了，但内容没有改变，也会造成 Last-Modified 失效。
>
> 在性能上，Last-Modified 优于 ETag 。因为 ETag 需要根据资源的内容生成唯一的哈希值，而 Last-Modified 只需要存储资源最后修改的时间。



## 1.3 缓存位置

优先级从高到低：

1. Service Worker
2. Memory Cache —— 内存缓存
3. Disk Cache —— 硬盘缓存
4. Push Cache —— 推送缓存，http2



# 2. 浏览器本地存储

* Cookie
* WebStorage
  * LocalStorage
  * SessionStorage
* IndexedDB



## 2.2 Cookie

​	最早是为了弥补HTTP在状态管理上的不足而设计的。所以 `Cookie` 使用来做状态存储的。

特性：

* 最大存储容量为4K
* 在设置的过期时间之前一直有效
* 数据可以保存在服务器、客户端两边
* 键值对存储



## 2.3 LocalStorage

特性：

* 最大存储容量为5M+
* 永久存储，除非自己手动删除
* 数据保存在本地浏览器
* 键值对存储



## 2.4 SessionStorage

特性：

* 最大存储为5M+
* 会话存储，关闭会话后数据被删除，当然也可以手动删除
* 数据保存在浏览器本地
* 键值对存储



# 3. 从输入URL到页面加载的全过程

1. 在浏览器中输入 URL，回车后，根据 URL 创建请求行
2. 从缓存中查找请求的资源，并检查是否有效。（通过强缓存、协商缓存检查）。如果有效命中则直接使用，否则进行下一步。
3. 获取域名对应的 ip地址。首先从本地的缓存中查找，如果没有则进行 DNS域名解析 。
4. 获取MAC地址，为数据传输做准备。
5. TCP三次握手创建连接
6. 判断是否是HTTPS请求，是的话，还需要进行TLS四次握手之后才能进行进行数据传输。
7. 服务器返回响应数据。客服端判断响应头的 `connection` 字段是否进行持久连接。是则一直保存，否则，TCP四次挥手断开连接。
8. 根据HTML文件解析生成 `DOM` 树。
9. 根据CSS文件解析生成 `CSSOM` 树。
10. 根据 `DOM` 树和 `CSSOM` 树，构建渲染树。
11. 根据渲染树建立布局树。
12. 布局完成后，浏览器对页面进行绘制，然后显示页面。
13. 可选择断开TCP连接。



# 4. 防抖、节流

​	防抖参考冴羽大佬的[《JavaScript专题之跟着underscore学防抖》](https://github.com/mqyqingfeng/Blog/issues/22)

​	节流参考冴羽大佬的[《JavaScript专题之跟着underscore学节流》](https://github.com/mqyqingfeng/Blog/issues/26)



## 4.1 防抖

​	**核心思想：**

​		在定时器时间内，每次事件触发都会删除原来的定时器，然后再新建定时器。

​		因此，多次事件触发，只会执行最后一次。类似回城。

​	[源码练习地址](https://github.com/C-G-L-A-D/font-review/blob/main/code/%E9%98%B2%E6%8A%96.js)



## 4.2 节流

​	**核心思想：**

​		如果在定时器的时间范围内再次触发，则不予理睬。等当前的定时器完成后，才能启动下一个定时器任务。

​		因此，多次事件触发，只会先完成最先触发的那次事件，只有等待最新触发的事件完成后，才会执行下次事件触发。也是优先选择最先触发的事件。类似技能CD。

​	[源码练习地址](https://github.com/C-G-L-A-D/font-review/blob/main/code/%E8%8A%82%E6%B5%81.js)