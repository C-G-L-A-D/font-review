# 1.  浏览器缓存

浏览器中的缓存分为两种情况：

* 强缓存，不需要发送HTTP请求
* 协商缓存，需要发送HTTP请求



# 1.2 缓存机制

 1. 首先浏览器会通过相应的字段来检测强缓存是否可用，在 `http1` 中 使用的是 **Expire** ，在 `http1.1` 之后使用的是 **catch-control**。这两个字段都是通过服务器的响应头进行返回。当两个字段同时存在时，有限考虑 **catch-control**。

    * **Expire**：`过期时间`， 表示客服端可以在这个过期时间之前直接从缓存中获取数据，无需请求。但是，由于服务器和客户端的时间可能不一样，导致过期时间并不准确。所以在 `http1.1` 被抛弃

    * **cache-control**：存储的是过期时长。例如 `cache-control:max-age=60` 即响应返回后60s失效。除了 `max-age` 属性外，还有：

      * `public`：表示客户端和代理服务器也可以缓存；

      * `private`：表示只有客服端可以缓存；

      * `no-cache`：跳过强缓存，直接进行协商缓存

      * `no-store`：表示不可以进行缓存

      * `s-maxage`：表示代理服务器得缓存时长。

        

 2. 如果强缓存失效了，就发送HTTP请求进行协商缓存。协商缓存通过在HTTP请求头中携带相应的 `缓存Tag` ，让服务器进行判断是否使用缓存还是更新资源。 `缓存Tag` 也分两种，在两种标识都存在的时候优先考虑**ETag** ，但是两种标识各有千秋。

    * **ETag**：由服务器根据资源的内容生成唯一的哈希值。由客户端发送请求头的 `If-None-Match` 携带，与服务器上资源的 **ETag** 进行判断，如果相同则返回304，让客户端使用缓存；反之，不相同则返回新的资源。
    * **Last-Modified**：存储的是资源最后的修改时间。由客户端发送请求头的`If-Modified-Since` 携带，与服务器上资源的最后修改时间进行比较。如果服务器最后修改时间较新，则返回新的资源；反之，返回304，让客户端使用缓存资源。

> 在 精确度 上，ETag 优于 Last-Modified，因为 ETag 是根据资源内容在判断，而Last-Modified的感知单位时间是秒，也就是说如果服务器上的资源在1s内多次修改，Last-Modified 是感知不到资源的修改。并且如果文件编辑了，但内容没有改变，也会造成 Last-Modified 失效。
>
> 在性能上，Last-Modified 优于 ETag 。因为 ETag 需要根据资源的内容生成唯一的哈希值，而 Last-Modified 只需要存储资源最后修改的时间。



# 1.3 缓存位置

优先级从高到低：

1. Service Worker
2. Memory Cache —— 内存缓存
3. Disk Cache —— 硬盘缓存
4. Push Cache —— 推送缓存，http2



# 2. 浏览器本地存储

* Cookie
* WebStorage
  * LocalStorage
  * SessionStorage
* IndexedDB



# 2.2 Cookie

​	最早是为了弥补HTTP在状态管理上的不足而设计的。所以 `Cookie` 使用来做状态存储的