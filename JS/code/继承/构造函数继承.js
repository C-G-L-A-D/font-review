function Parent(age, name) {
    this.age = age
    this.name = name
}

function Child(name, age) {
    // 核心代码
    Parent.call(this, age, name)
}

/**
 * 核心：
 *   在子类构造函数中，将子类实例对象和参数传入父类的构造函数中并执行
 *   则子类的实例对象实际执行上下文环境是父类构造函数，因此可以使用父类的属性和方法。
 * 
 * 优点：
 *   解决了通过原型链继承导致不能传递参数和共用父类属性的问题
 * 
 * 缺点：
 *   1. 每次创建子类实例对象都会运行一次父类的构造函数，
 *      因此，每个子类实例对象所继承的父类方法不是同一个，
 *      即父类方法不能重用。
 *   2. 继承的父类方法只能在构造函数中定义
 * 
 */