# 1. 什么是TCP

​	TCP是**面向连接**、**可靠的**、**基于字节流**的**传输层**通信协议。



# 2. TCP 三次握手

1. 初始状态，客户端和服务器都处在 `CLOSE(关闭)` 状态。当服务器开启后，会主动监听某些端口，处于 `LISTEN(监听)` 状态。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4964/image-20220926164531016.png" alt="image-20220926164531016" style="zoom:50%;border:1px solid black;" />



2. 当客户端发起连接请求时，会发送一个SYN 报文给服务端，并且随机初始化序列号，将SYN控制位设为1。表示发起连接。随即，客户端进入 `SYN_SENT` 状态。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4964/image-20220926165329142.png" alt="image-20220926165329142" style="zoom:50%;" />

3. 服务器接收到SYN报文后，也随机初始化自己的序列号(server_isn) ，将**确认应答号**设置为 `客户端序列号+1` ，然后把 SYN 和 ACK 控制位设置为1。最后将这个报文发送给客户端。表示确认客户端的连接请求，并且发送自己的连接请求。之后服务端处于 `SYN_RCVD` 状态。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4964/image-20220926171012085.png" alt="image-20220926171012085" style="zoom:50%;" />

4. 客户端接收到服务端报文后，还要响应服务端一个确认应答报文，即ACK报文。告知服务端可以进行连接。因此需要将报文 ACK 控制位设置为1，并且确认应答号设置为 `服务端序列号 + 1` 。发送报文后，客户端处于 `ESTABLISHED` 状态。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4964/image-20220926171740800.png" alt="image-20220926171740800" style="zoom:50%;" />

5. 服务端接收到确认报文后，也进入 `ESTABLISHED` 状态。此时TCP创建连接完成。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4964/image-20220926171936734.png" alt="image-20220926171936734" style="zoom:50%;" />



> ps: 第三次握手的时候可以携带数据，也就是 步骤 4 返回 ACK 报文时可以携带数据。



# 3. 为什么 TCP 连接不能是两次握手

​	原因如下：

* **三次握手可以阻止重复历史连接的初始化（主要原因）**；
* **三次握手可以同步双方初始序列号**；
* **三次握手可以避免浪费资源**。



​	因为当 TCP 是两次握手时，如果第一次发送 SYN 报文请求创建连接时发生网络拥堵导致超时。则会触发 TCP 重传机制，再次发送 SYN 报文。

​	此时，若 `旧的SYN报文` 比 `新的SYN报文` 早一步到达服务端，则服务端就会返回应答。

​	而客户端接收到 `旧SYN报文的应答报文` 后，通过序列号判断出是历史连接，于是客户端会发送 `RST报文`  给服务端，表示终止这次连接。

​	而网络拥堵等情况，可能会发送多次历史连接，造成资源浪费。



​	并且由于两次握手，导致服务端没有应答报文，无法确认客户端接收到的服务端序列号是否一致。



# 4. TCP 三次握手丢包后会发生什么

## 4.1 第一次握手时发生丢包

​	当第一次握手时发生丢包，服务端没有接收到客户端发送的 `SYN报文` 就无法发送对应的 `ACK报文` 。

​	而客户端超时时间内没有接收到 `ACK报文` 会认为发生了丢包，触发**超时重传**机制。

​	如果超过了操作系统内核指定的重传次数，客户端还没有接收到回应的ACK报文，就不再发送SYN包，然后直接进入 `CLOSE` 状态取消TCP连接。



## 4.2 第二次握手时发生丢包

​	第二次握手是服务端发送 `ACK + SYN` 报文。如果发生丢包，客户端接收不到第一次握手发送的 `SYN` 报文的应答报文。与第一次握手丢包相同，客户端触发丢包重传机制。

​	同时服务端发送了SYN报文，也没有接收到对应的ACK报文，也会触发丢包重传机制。

​	如果双方都没有在指定重传次数前收到报文则会取消连接，都进入CLOSE状态。



## 4.3 第三次握手时发生丢包

​	第三次握手只有服务端需要应答报文。而客户端进入了 `ESTABLISHED` 状态。如果此时发生丢包，则

​	服务端会触发超时重传机制，在指定重传次数内重新发送SYN报文；超过重传次数没有接收到 ACK报文 就会断开连接。



# 5. TCP 断开连接（四次挥手）

​	通信双方都可以主动断开连接，断开连接后，主机的资源将被释放。以下步骤模拟客户端断开连接：

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4964/image-20220926180530669.png" alt="image-20220926180530669" style="zoom:50%;" />

1. 客户端主动断开连接，发送一个 `FIN报文` 给服务端，即将 ` FIN` 控制位设置为1 。然后进入 `FIN_WAIT_1` 状态；
2. 服务端接收到请求断开连接的 `FIN报文` 后，向客户端发送 `ACK应答报文` 。然后进入 `CLOSE_WAIT` 状态；
3. 客服端接收到应答报文后，进入 `FIN_WAIT_2` 状态；
4. 带服务端处理完数据后，也向客户端发送 `FIN报文`，表示可以断开连接了。之后服务端进入 `LAST_ACK` 状态；
5. 客户端接收到服务端的 `FIN报文` 后，发送对应的 **ACK应答报文**，然后进入 `TIME_WAIT` 状态；
6. 服务端接收到 `ACK应答报文` 后，就进入 `CLOSE` 状态。此时服务器完成连接关闭；
7. 客户端在进入`TIME_WAIT` 状态后，继续等待 `2MSL` 时间。然后自动进入 `CLOSE` 状态。此时客户端完成连接关闭。



# 6. 为什么TCP断开连接需要四次挥手

​	当客户端主动断开连接发送 FIN 报文时，仅仅代表客户端不在发送数据，但是还能就收数据。

​	而服务端在接收到第一次挥手时，会先返回一个应答报文表示收到断开申请。但是此时可能还有一些数据还没进行处理或发送。因此只有服务端不在发送数据了之后，才会发送FIN报文来同意关闭连接。

​	所以服务器的 ACK 和 FIN 需要分开发送。



# 7. TCP 重传机制

常见的重传机制：

* 超时重传
* 快速重传
* SACK
* D-SACK



# 7.1 超时重传

​	在发送数据包时，设定一个定时器，当等待接收对应的 `ACK报文` 时间超过指定的时间后，就会重新发送该数据。因此发生超时重传的情况有 **数据包丢失** 和 **确认应答丢失** 。



`RTT` 是 数据包发送到接收到对应的确认应答报文的时间。即包往返时间

`RTO` 是 超时重传时间。

* 当 `RTO` 较大时，重传慢，导致效率低，性能差；

* 当 `RTO` 较小时，重传快，如果包还没有丢失就重发，会导致网络拥塞，从而导致更多包超时，循环重传。

因此，`RTO` 的值应该根据网络情况进行调整，所以是个动态的值。



**缺点：**

​	重传周期较长，每次重传时间是上次的两倍。因此有了快速重传机制。



## 7.2 快速重传

​	根据数据驱动重传。每个数据包都会有一个对应的 `ACK确认应答报文` ，而 `ACK报文` 的确认应答号会指定下一个需要接受的数据包。

​	当发生丢包时，接收方接收到其他数据包后，返回的应答报文都是会指定传输丢失的数据包。

​	而发送方接收到的都是指定同一个数据包的 **ACK报文**，就会意识到发生丢包了。然后就重新传输丢失的数据包。



**缺点：**

​	不知道是重传多少个数据包，一个一个传麻烦。因为可能接收方知道某个数据包丢失，但是不知道它之后的数据包是否都丢失。因此有了 **SACK机制**



## 7.3 SACK（选择性确认）

​	需要在TCP头部选项字段中加入一个 `SACK` ，将已经接收到的数据信息发送给发送方，由此发送方就知道那些包丢失。



## 7.4 D-SACK

​	使用 `SACK` 来告诉发送方有哪些数据被重复接收了。用途有：

* 告知发送方 ACK报文丢失
* 网络延迟



# 8. 滑动窗口

**作用：**

​		无需等待确认应答，持续发送多个数据包。



**原因：**

​		由于在传输数据包时，如果需要等待确认应答之后才能继续发送下一个数据包，可能会因为 `RTT(数据包往返时间)` 越长，通信的效率越低。

 

**窗口的实质：**

​		窗口实际上是操作系统开辟的一个缓存空间，发送方在等待确认应答返回之前，必须在缓冲区保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。



**累计确认（累计应答）模式：**

​		如果有 ACK报文① 丢失，可以通过下一个 ACK报文② 进行确认。如果 ② 比 ① 大，则说明 ② 之前的报文都已经接收到了。因此可以继续发送。如果 ② <= ①，则说明有丢包，接收方没有收到。



**窗口大小：**

​		TCP 报文有个头字段 `Window` ，代表接收方还有多少缓冲区可以接收数据，也就是指窗口大小。因此，窗口大小通常都是由接收方的窗口大小来决定，这样发送方就可以根据接收方的处理能力来发送数据，而不会导致接收方处理不过来。

​		接收窗口的大小是约等于发送窗口的大小。因为滑动窗口的大小不是一成不变的，接收方通过TCP报文告知发送方窗口大小的过程是存在时延的。所以是约等于的关系。



# 9. 流量控制

​		**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

​		发送方会根据接收方的窗口大小，更改自己发送数据包的大小。只有在接收到对应的确认应答包，才会释放自己窗口（缓冲区）的数据。如果窗口已满则不能发送。

​	**但是当发送方的可用窗口变为0时，发送方会定时发送窗口探测报文来了解接收方的窗口是否发生改变。**

​	若接收方还剩部分数据没有处理就缩小窗口，然后发送方不知道继续发送数据包，就会导致数据包大小大于接收方可用窗口大小，那么接收方会将数据包丢掉。因此，为了防止这种情况发生，**TCP只允许先收缩窗口，在减少缓存，从而避免丢包。**



## 9.2 窗口关闭潜在死锁现象

​	接收方是通过ACK报文来了解到发送方的窗口大小从而进行流量控制。如果窗口大小为0，则窗口关闭，就会阻止发送方给接收方传递数据，知道窗口变为非0；



**原因：**

​		如果窗口关闭后接收方发给发送方告知其可用窗口非0的ACK报文丢失了，就会导致发送方一直等待接收方窗口可用的通知，而接收方也会一直等待发送方的数据。如果采取措施，就会造成死锁。



**解决方法：**

​		TCP 为每个连接设有一个持续定时器，**只要连接一方接收到对方零窗口的通知，就启动持续计数器** 。如果持续计时器超时，则会发送**窗口探测报文**：

* 如果接收方可用窗口仍为0，则收到零窗口的一方重新启动持续计时器；一般窗口探测次数为3次，如果3次过后还是0，有些TCP会发送 `RST` 报文来中断连接；
* 如果接收方可用窗口不为0，则解决死锁问题。



# 10. 拥塞控制

​		虽然有了流量控制避免接收方的缓存被填满，但是我们并不知道网络中发生了什么，有可能是网络中其他主机的通信使得网络拥堵。

​		在发送网络拥堵时，如果继续发送大量的数据包，可能会导致数据包时延、丢失等，从而触发TCP重传机制。但是重传数据包会导致网络负担更大，从而造成恶性循环。因此当网络发生拥塞时，TCP会降低放松的数据量，进行**拥塞控制，避免 发送方 的数据填满整个网络**。

​		**拥塞窗口(cwnd)是在发送方调节要发送的数量。它会根据网络的拥塞程度动态变化。所以此时，发送方的滑动窗口大小是拥塞窗口和接收窗口中的最小值。**



##### 如何判断网络是否出现拥塞？

​	发生超时重传时。



## 10.2 拥塞控制算法

* 慢启动
* 拥塞避免
* 拥塞发生
* 快速恢复



### 10.2.1 慢启动

​		在TCP刚创建连接完成后，首先是有个慢启动的过程，也就是一点一点的提高发送数据包的数量。

​		当发送方每收到一个 ACK ，拥塞窗口的大小就会增加一倍。发包的个数是指数性增长的。数据包增长到 `慢启动门限(ssthresh)` 后就会使用**拥塞避免算法**。即

* 当 `cwnd < ssthresh` 时，使用慢启动算法
* 当 `cwnd >= ssthresh` 时，使用拥塞避免算法

> 一般来说 ssthresh 的大小是 65535 字节。



### 10.2.2 拥塞避免

​		每当收到一个 ACK 时，cwnd 就增加<img src="C:%5CUsers%5CLad%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220926213935046.png" alt="image-20220926213935046" style="zoom:50%;" />。从而变成线性增长。



### 10.2.3 超时重传

​		网络发生拥塞后，就会发生数据包重传。主要通过超时重传和快速重传机制。触发超时重传机制后，cwnd会被重置为1，重新开始慢启动。



### 10.2.4 快速恢复

​		快速恢复一般和快速重传同时使用。因为快速恢复算法认为，此时如果还能收到三个重复的 ACK 说明网络也不算太差。不需要像超时重传一样那么强烈。**在进入快速恢复之前**，**将 cwnd 设置为原来的一般，将 ssthresh 设置为 cwnd。**

​	进入快速恢复后，

* cwnd = ssthresh + 3 （表示收到重复的三个 ACK）
* 重传丢失的数据包
* 如果再收到重复的 ACK ，cwnd += 1
* 如果收到新的数据 ACK，则 cwnd = ssthresh 。恢复结束。