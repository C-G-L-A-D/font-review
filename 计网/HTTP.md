# 1. 网络模型

## 1.1 OSI 网络模型（从上至下，7层）

* 应用层 —— 负责为应用程序提供统一的接口
* 表示层 —— 负责把数据转换成兼容接受系统的格式、解析、加密、压缩等（SSL记录协议）
* 会话层 ——负责维护计算机之间的通信连接，通讯双方身份认证、协商加密等。（提供DNS，SSL握手协议）

* 传输层（TCP、UDP传输协议）

* 网络层（IP协议，包括ICMP、ARP协议等）

* 数据链路层（网卡、交换机之类的）

* 物理层



## 1.2 TCP/IP 网络模型（从上至下，4层）

* 应用层

  * 将应用数据传输给下一层；

  * 提供 HTTP、FTP、DNS 等服务。

* 传输层

  * 负责端到端的通信；
  * 可使用 TCP、UDP协议封装报文数据；

  * 当报文数据超过 `TCP最长报文段长度（MSS）` 时，会对TCP段进行**切片**。（需要重传的时候，就可以只重新发送一个切片的TCP）。

* 网络层 

  * 负责网络包的封装、寻址和路由选择；
  * 可使用 IP 协议，包含 ICMP、ARP协议等；
  * 当 IP包超过 `网络接口配置的最大传输单元（MTU，以太网中最大为1500字节）` 时，会进行**切片**。

* 网络接口层

  * 负责数据帧在物理网络中的传输，比如MAC寻址、错误侦测以及通过网卡传输数据帧等；
  * 在此层给 IP包添加帧头和帧尾。帧头包含 MAC 头部，帧尾用于差错校验。



# 2.HTTP

## 2.1 HTTP是什么？

​	HTTP是超文本传输协议。

* 协议：行为约定和规范；

* 传输：两点之间传输数据；
* 超文本：文字、图片、音频、视频等数据格式的混合体。

**总结：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**



## 2.2 HTTP常见状态码

<table>
    <thead>
        <th>类</th>
        <th>常用状态码</th>
        <th>状态码对应含义</th>
        <th>类含义</th>
    </thead>
    <tbody>
        <tr>
            <td>1xx</td>
            <td>暂无</td>
            <td>暂无</td>
            <td>信息状态码，表示协议处理的中间状态，还需要后续的处理</td>
        </tr>
        <tr>
            <td rowspan="3">2xx</td>
            <td>200 OK</td>
            <td>客户端发来的请求被服务器正常处理</td>
            <td rowspan="3">成功状态码，表示请求正常处理完毕</td>
        </tr>
        <tr>
            <td>204 No Content</td>
            <td>与200相同，但是没有响应体</td>
        </tr>
        <tr>
            <td>206 Partial Content</td>
            <td>客户端进行范围请求，服务器响应返回部分内容。通过Content-Range响应头字段指定内容范围。使用场景为HTTP分块下载和断点续传</td>
        </tr>
        <tr>
            <td rowspan="4">3xx</td>
            <td>301 Moved Permanently</td>
            <td>永久重定向。表示请求资源已经分配新的UPI，需要改用新的URI进行访问</td>
            <td rowspan="4">重定向状态码，表示客户端请求的资源发生变动。（301、302、303响应状态码返回时，几乎所有的浏览器都会把Post请求改为Get请求，并删除请求体。之后请求会自动发送。）</td>
        </tr>
        <tr>
            <td>302 Found</td>
            <td>临时重定向。请求资源还在，但是暂时需要使用另一个URL访问</td>
        </tr>
        <tr>
            <td>303 See Other</td>
            <td>资源存在另一个URI，需要通过Get方法定向获取请求资源。</td>
        </tr>
        <tr>
            <td>304 Not Modified</td>
            <td>浏览器缓存相关。告诉客户端使用缓存数据，只返回响应头信息。</td>
        </tr>
        <tr>
            <td rowspan="5">4xx</td>
            <td>400 Bad Request</td>
            <td>表示请求报文中存在错误，但不知道具体是哪。</td>
        	<td rowspan="5">客户端错误状态码，表明客户端发送报文有误，服务器无法处理。</td>
        </tr>
        <tr>
            <td>401 Unauthorized</td>
            <td>表示请求需要包含用户认证信息。</td>
        </tr>
        <tr>
            <td>403 Forbidden</td>
            <td>服务器禁止访问资源</td>
        </tr>
		<tr>
            <td>404 Not Found</td>
            <td>请求资源不存在或找不到，服务器无法提供。</td>
        </tr>
        <tr>
            <td>405 Method Not Allowed</td>
            <td>服务器禁止使用该请求方法。</td>
        </tr>
        <tr>
            <td rowspan="4">5xx</td>
            <td>500 Internal Server Error</td>
            <td>服务器发生错误，但是不知道具体什么错误。</td>
            <td rowspan="4">服务器错误状态码。表示客户端请求报文正确，但是服务器处理时内部发生错误。</td>
        </tr>
        <tr>
            <td>501 Not Implemented</td>
            <td>客户端请求的功能还不支持。</td>
        </tr>
        <tr>
            <td>502 Bad Gateway</td>
            <td>服务器自身正常，但是访问后端出现错误。具体错误不知道。</td>
        </tr>
        <tr>
            <td>503 Service Unavailable</td>
            <td>表示服务器正处于超负载或正在停机维护，无法处理请求。</td>
        </tr>
    </tbody>
</table>



## 2.3 HTTP的 Accept 字段

​	可分为四个部分：**数据格式**、**压缩方式**、**支持语言**和**字符集**



* 数据格式：支持一部分MIME标准的数据类型。发送方通过 `Content-type` 字段传输，接收方通过 `Accept-type` 字段指定接收的数据类型；
* 压缩方式：发送方使用 `Content-Encoding` 字段，接收方使用 `Accept-Encoding` 字段；
* 支持语言：发送方使用 `Content-Language` 字段，接收方使用 `Accept-Language` 字段；
* 字符集：接收方通过 `Accept-Charset` 字段指定可以接收的字符集。发送方是放在了 `Content-type` 字段中，以 `charset` 属性进行指定。例如: `Content-type: text/html; charset=utf-8` 。



# 3. HTTP/1.0 和 HTTP/1.1 的区别

1. **连接方面：**

   ​	HTTP/1.0 默认使用非持久连接，每发起一个请求都要经过TCP三次握手创建连接。并且多个请求是串行的，做了无谓的TCP连接创建和断开，从而增加了通信开销。

   ​	因此 HTTP/1.1 默认使用持久连接的通信方式来使多个请求复用同一个TCP连接。减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端负载。

   

2. **资源请求方面：**

   ​	HTTP/1.1 在请求头引入了 `range` 字段，允许之请求资源的部分内容。从而支持断点续传并且节省了带宽。

   ​	HTTP/1.0 如果需要请求资源的部分内容的话，是将整个资源对象进行传输，造成了带宽浪费现象。

   

3. **缓存方面：**

   ​	HTTP/1.0 中主要使用 header 里的 `If-Modified-Since` 和 `Expires` 来做为缓存判断标准。

   ​	HTTP/1.1 则引入了更过缓存控制策略，例如：`Etag` 、`Cache-Control` 等更多可供选择的缓存头来控制缓存策略；

   

4. **指定服务器域名方面：**

   ​	HTTP/1.0 中认为每台服务器都绑定一个唯一的IP地址，因此在请求消息中并没有传输主机名（hostname）。

   ​	HTTP/1.1 中新增了 `host` 字段，用来指定服务器的域名。因为随着虚拟主机技术发展，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个IP地址。通过 `host` 字段可以将请求发送到同一台服务器的不同网站上。

   

5. **请求方法：**

   ​	HTTP/1.1 相对于 HTTP/1.0 新增了很多请求方法，例如： `PUT` 、 `HEAD` 、`OPTIONS` 等。



# 4. HTTP/1.1 特性

## 4.1 HTTP/1.1 优点

​	HTTP/1.1 优点有**简单**、**灵活和易于扩展**、**应用广泛和跨平台**



1. **简单**

   ​	基本报文格式是 `head + body` ，头部信息也是 `key-value` 简单文本形式，**易于理解**。

   

2. **灵活和易于扩展**

   ​	HTTP协议中报文字段、请求方法、状态码等组成要求都没有被固定死，**允许开发人员自定义和扩充**。

   ​	HTTP工作在应用层，它的**下层可以随意变换**。例如：HTTPS 在 HTTP 和 TCP 层之间加了 SSL/TLS 安全传输层、HTTP/3 将TCP层换成了基于 UDP 的 QUIC。

   

3. **应用广泛和跨平台**

   ​	天然具有**跨平台**优越性，互联网各个平台、应用都使用。



## 4.2 HTTP/1.1 缺点

​	HTTP/1.1 的缺点有 **高延迟**、**无状态**、**明文传输**。



1. **高延迟 —— 队头阻塞**

   ​	虽然 HTTP/1.1 使用持久连接复用一个 TCP 管道，但是一个管道同一时刻只能处理一个请求，在当前请求没有结束前，其他请求只能处于阻塞状态。由于发生了队头阻塞，导致带宽无法被充分利用，从而造成了网络延迟。

   

2. **无状态双刃剑 —— 带来巨大的 HTTP 头部**

   ​	无状态使得服务器不会去记忆 HTTP 的状态，因此也不需要使用额外的资源来记录状态信息，从而减轻服务器的负担。

   ​	但是由于 HTTP 的无状态特性，导致报文的 `header` 部分总是需要携带 `Cookie` 、`Accept` 、`User Agent` 等许多固定的头字段，但是可能 `body` 部分携带的数据内容很少。并且响应报文中有大量的字段值都是重复，非常浪费。因此无状态特性导致**Header里携带的内容过大并在一定程度上增加了传输成本**。

   

3. **明文传输 —— 不安全**

   ​	明文传输，导致**内容可能会被窃听**（抓包获取）。同时也**无法保证报文的完整性**，因为有可能篡改。也因此客服端和服务器双方都**无法验证通信方的身份**，更不能保证数据的安全性了。



## 4.3 HTTP/1.1 的性能

​	HTTP协议基于 TCP/IP ，并且使用了**请求 - 应答**的通信模式。



1. **长连接（持久连接）**

   ​	解决 HTTP/1.0 增加通信开销的来连接问题。减轻了服务器端的负载。只要任意一端没有明确提出断开连接，则保持 TCP连接状态。不过，如果长连接一定时间内都没有任何的数据交互，服务器段会主动断开连接。
   
   
   
2. **管道网络传输**

   ​	允许在同一个TCP连接中同时发送多个请求，**减少整体的响应时间**。但是服务器必须按照接收请求的顺序发送对对应的响应。因此如果前面的请求处理耗时较长，则会造成阻塞。因此，**HTTP/1.1 管道化传输解决了请求的队头阻塞，但是没有解决响应的队头阻塞。**

   

3. **队头阻塞**



## 4.3 HTTP/1.1 优化

​	可以从以下三个思路来优化 HTTP/1.1 协议：

* 尽量避免发送HTTP请求；
  * 缓存
* 需要发送HTTP请求时，考虑如何减少请求次数；
  * 减少重定向请求次数（将重定向交由代理服务器完成）
  * 合并请求（雪碧图，webpack打包等，但是更新部分资源就麻烦了）
  * 延迟发送请求（懒加载）
* 减少服务器的HTTP响应数据大小；
  * 无损压缩（gzip、br等）
  * 有损压缩



# 5. HTTP/2

## 5.1 HTTP/2 新特性



1. **头部压缩**

2. **二进制传输**

3. **多路复用（并发传输）**

   * 同个域名下的所有通信都在单个连接上完成；

   * 单个连接可以承载任意数量的双向数据流

   * 数据流以消息的形式发送，一个消息由一或多个帧组成。

   * 多个帧可以乱序发送，通过帧首部的流标识进行重新组装

     **解决了HTTP/1.1队头阻塞，提高了传输的吞吐量**

4. 服务器主动推送（Server Push）

   ​	可以在浏览器请求HTML的时候提前把会用到的 JS、CSS 文件发给客户端，减少等待的延迟。客户端有权利选择是否接收。



## 5.2 HTTP/2 缺点

* **队头阻塞没有完全解决**

  ​	基于 TCP 传输，会有丢包重传机制。当发生 TCP丢包时，整个 TCP 连接都需要等待重传，从而阻塞 TCP 连接中的所有请求。

* **TCP 以及 TCP 与 TLS 的握手时的延迟**

  ​	需要经历 TCP 三次握手和 TLS 握手成功后才能进行数据传输。

* **多路复用导致服务器压力上升**

  ​	多路复用没有限制同时请求数，有时可能会爆发大量的请求。

* **多路复用容易造成超时**

  ​	网络带宽和服务器资源有限，当连接中存在多个并行的流时，每个流的资源会被稀释，从而可能会造成超时。

* **网络迁移需要重新连接**

  ​	基于 TCP 连接，只要IP地址或者端口号变动都需要重新建立连接。此问题是相对与 UDP传输协议，HTTP/3是基于 UPD 。



# 6. HTTP/3

​	HTTP/3 将传输协议换成了 UDP，并且基于 UDP 协议在「应用层」实现了 **QUIC** 协议。

​	UDP 协议是 无连接 的，所以比 TCP 快。但是不靠谱。

​	而 QUIC 在 UDP 协议的基础上，实现了 拥塞窗口、流量控制 等类似TCP的可靠性功能。



## 6.2 QUIC 新特性

1. 通过多路复用解决队头阻塞问题；
2. 建立连接速度更快，但是集成了TLS加密，还需要 TLS 握手；
3. 连接迁移，通过客户端生成 Connection ID来区别连接；
4. 实现了类似TCP的流量控制、传输可靠性的功能。



# 7. HTTPS

## 7.1 概念

​	超文本传输安全协议。经由 HTTP 进行同行， 利用 SSL/TLS 来加密数据包。

HTTPS 在 HTTP 层和 TCP 层中甲加入了 SSL/TLS 安全层来对HTTP报文进行加密和解密。提供**身份验证**、**信息加密**和**完整性校验**的功能，从而解决HTTP明文传输，存在信息窃听、信息篡改和信息劫持的风险。

* 混合加密

  * 建立通信前，采用非对称加密的方式交换会话密钥。
  * 通信建立过程中，全部使用**对称加密的会话密钥**加密明文数据。

* 摘要算法

  ​	用摘要算法（哈希算法）计算内容的哈希值，也就是内容指纹。

* 数字签名

  ​	通过**私钥加密**，**公钥解密**的**非对称加密算法**方式来确认消息身份。

* 数字证书

  ​	CA(数字证书认证机构) 会将 服务器信息 + 服务器公钥 + 公钥的数字签名 打包成一个数字证书。



## 7.2 数字证书工作流程

**前提：**CA的公钥已经存储再浏览器或者服务器中。

		1. 服务器将自己的**公钥注册到 CA**；
  		2. CA 使用自己的私钥**对服务器的公钥进行数字签名**，然后**颁发数字证书**；
  		3. 服务器将自己的数字证书发送给客户端后，客户端**使用 CA 的公钥对数字证书进行确认**。 
  		4. 确认了数字证书的真实性后，通过数字证书中的**服务器公钥**对即将发送的**报文**进行**加密发送**；
  		5. 服务器**使用私钥对报文进行解密**；



## 7.3 SSL/TSL 连接

1. 客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。请求中包含以下信息：
   * 客户端支持的SSL/TSL协议版本号
   * 客户端生成的随机数
   * 客户端支持的加密方式
2. 服务器收到请求后，向客户端发出响应，即 `ServerHello` 请求。请求中包含以下信息：
3. 







# 8 HTTP 和 HTTPS 的区别

1. **安全性**

   ​	HTTP 的报文信息是明文传输，存在安全风险问题；

   ​	HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使报文能够加密传输。

   

2. **连接方面**

   ​	HTTP 只需要经过 TCP 三次握手之后便可以进行 HTTP 的报文传输；

   ​	HTTPS 则需要在 TCP 三次握手之后，还要进行 SSL/TLS 的握手过程，才可以进入加密报文。

   

3. **端口号**

   ​	HTTP 的端口号是 80；

   ​	HTTPS 的端口号是 443。

   

4. **通信双方身份验证**

   ​	HTTP 协议的通信双方无法进行身份验证；

   ​	HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。





# 9. GET 和 POST 的区别

* **是否缓存：**Get请求一般会被浏览器缓存，POST默认不会
* **安全性：**Post请求相对于Get请求较安全，因为Get请求的参数一般是写在URL上的，Post请求参数一般放在请求体
* **编码：**因为URL规定只支持ASCII码，所以一般Get请求只支持ASCII码，Post请求支持编码格式更多。
* **请求长度：**因为浏览器限制URL的长度，所以一般Get请求会有影响，Post请求没有。
* **幂等性：**一般Get请求是幂等的，Post不是。幂等是指执行多少次结果都不变。

以上均为出来缓存，其余均为一般情况，指的是RFC规范规定的情况。

>  根据RFC规范，Get请求是获取资源，Post请求是根据请求负荷（报文body）对资源做出处理。
>
> Post请求携带的数据一般是写在报文body中，Get请求携带数据一般是写在URL上。
>
> 但是由于http是明文传输，所以Post请求参数能够通过抓包看到，所以没有绝对安全。

